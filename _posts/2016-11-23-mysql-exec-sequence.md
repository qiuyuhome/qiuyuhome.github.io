---
layout: post
title: MySQL语句的执行顺序
categories: SQL
description: MySQL语句的执行顺序
keywords: MySQL, 执行顺序
---

MySQL的语句一共分为 11 步. 理解了这 11 步, 才能写出正确的 sql 语句. 别问我为什么.


最先执行的总是 `FROM` 操作，最后执行的是 `LIMIT` 操作。

其中每一个操作都会产生一张虚拟的表，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的.

但是只有最后一个虚拟的表才会被作为结果返回。如果没有在语句中指定某一个子句，那么将会跳过相应的步骤。

---


## 具体的流程

| 顺序 | 关键字           | 解释                                                                                                                                                                                                                                                  |
|:----|:----------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1   | FORM            | 对 `FROM` 的左边的表和右边的表计算笛卡尔积。产生虚表 `VT1`                                                                                                                                                                                                    |
| 2   | ON              | 对虚表 `VT1` 进行 `ON` 筛选，只有那些符合 `<join-condition>` 的行才会被记录在虚表 `VT2` 中。                                                                                                                                                                    |
| 3   | JOIN            | 如果指定了 `OUTER JOIN`（比如 `left join`、 `right join`），那么保留表中未匹配的行就会作为外部行添加到虚拟表 `VT2` 中，产生虚拟表 `VT3`, `rug from`子句中包含两个以上的表的话，那么就会对上一个 `join` 连接产生的结果 `VT3` 和下一个表重复执行步骤 1~3 这三个步骤，一直到处理完所有的表为止。 |
| 4   | WHERE           | 对虚拟表 `VT3` 进行 `WHERE` 条件过滤。只有符合 `<where-condition>` 的记录才会被插入到虚拟表 `VT4` 中。                                                                                                                                                           |
| 5   | GROUP BY        | 根据 `group by` 子句中的列，对 `VT4` 中的记录进行分组操作，产生 `VT5`.                                                                                                                                                                                        |
| 6   | CUBE 或者 ROLLUP | 对表 `VT5` 进行 `cube` 或者 `rollup` 操作，产生表` VT6`.                                                                                                                                                                                                  |
| 7   | HAVING          | 对虚拟表 `VT6` 应用` having` 过滤，只有符合 `<having-condition>` 的记录才会被 插入到虚拟表 `VT7` 中。                                                                                                                                                           |
| 8   | SELECT          | 执行 `select` 操作，选择指定的列，插入到虚拟表 `VT8` 中。                                                                                                                                                                                                     |
| 9   | DISTINCT        | 对 `VT8` 中的记录进行去重。产生虚拟表 `VT9`.                                                                                                                                                                                                                |
| 10  | ORDER BY        | 将虚拟表 `VT9` 中的记录按照 `<order_by_list>` 进行排序操作，产生虚拟表 `VT10`.                                                                                                                                                                                |
| 11  | LIMIT           | 取出指定行的记录，产生虚拟表 `VT11`, 并将结果返回。                                                                                                                                                                                                           |


---

## 笛卡尓积：

在数学中，两个集合X和Y的笛卡尓积（Cartesian product），又称直积.

表示为 `X × Y`，第一个对象是X的成员而第二个对象是Y的所有可能有序对的其中一个成员。

假设集合 A={a, b}，集合 B={0, 1, 2}，则两个集合的笛卡尔积为 {(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}。

类似的例子有，如果 A 表示某学校学生的集合，B 表示该学校所有课程的集合，则 A 与 B 的笛卡尔积表示所有可能的选课情况。
A 表示所有声母的集合，B 表示所有韵母的集合，那么 A 和 B 的笛卡尔积就为所有可能的汉字全拼。


